با کمال میل و افتخار. به عنوان یک معمار ارشد نرم‌افزار و مدرس با سابقه، باعث خرسندی من است که دانش و تجربیاتم را برای تدوین یک هندبوک برنامه‌نویسی در سطح جهانی، منطبق با استانداردهای برترین شرکت‌های فناوری، در اختیار شما قرار دهم.

این جزوه بر اساس تحلیل دقیق و کلمه به کلمه متون آموزشی ارائه شده توسط شما تهیه شده است تا یک راهنمای جامع، عمیق و در عین حال ساده و کاربردی باشد. هدف ما تنها انتقال مفاهیم نیست، بلکه پرورش یک تفکر مهندسی استاندارد و حرفه‌ای است.

با هم این مسیر را آغاز می‌کنیم.

***

### **درختواره ساختاری مباحث (Structural Tree)**

در این جلسه، ما بر روی دو محور اصلی تمرکز خواهیم کرد: تکمیل و داینامیک‌سازی رابط کاربری (UI) و سپس بازسازی (Refactoring) کدهای خود برای دستیابی به ساختاری تمیزتر و حرفه‌ای‌تر.

```
1. آماده‌سازی و استایل‌دهی اولیه Layout
   ├─ 1.1. یکپارچه‌سازی فریم‌ورک Tailwind CSS از طریق CDN
   └─ 1.2. رفع نیازمندی‌های اولیه CSS (تنظیم ارتفاع و پس‌زمینه)

2. داینامیک کردن محتوای صفحات با Blade
   ├─ 2.1. استفاده از اسلات پیش‌فرض (Default Slot) برای محتوای اصلی
   └─ 2.2. معرفی اسلات‌های نام‌گذاری شده (Named Slots) برای بخش‌های داینامیک مانند عنوان صفحه (Heading)

3. مدیریت هوشمند لینک‌های ناوبری (Navigation)
   ├─ 3.1. مسئله: استایل ثابت (Hardcoded) برای لینک فعال
   ├─ 3.2. راه‌حل اول: استایل‌دهی شرطی (Conditional Styling)
   │    ├─ 3.2.1. استفاده از اپراتور سه‌تایی (Ternary Operator) در PHP
   │    └─ 3.2.2. تشخیص مسیر فعلی با تابع کمکی request()->is()
   └─ 3.3. راه‌حل دوم (حرفه‌ای): بازسازی کد به یک کامپوننت Blade مجزا
        ├─ 3.3.1. ساخت کامپوننت NavLink.blade.php
        ├─ 3.3.2. درک تفاوت Props و Attributes در کامپوننت‌ها
        ├─ 3.3.3. تعریف Props با دایرکتیو @props
        └─ 3.3.4. مدیریت دسترسی‌پذیری (Accessibility) با aria-current
```

---

### **بخش ۱: آماده‌سازی و استایل‌دهی اولیه Layout**

در این بخش، ما ظاهر اولیه برنامه خود را با استفاده از فریم‌ورک محبوب Tailwind CSS شکل می‌دهیم و تنظیمات اولیه مورد نیاز آن را اعمال می‌کنیم.

#### **۱.۱. یکپارچه‌سازی فریم‌ورک Tailwind CSS از طریق CDN**

**فلوی گرامری (Grammar Flow):**

1.  برای استفاده سریع از Tailwind CSS بدون نیاز به ابزارهای ساخت (Build Tools)، ما آن را از طریق یک شبکه توزیع محتوا (CDN) به پروژه اضافه می‌کنیم.
2.  در فایل layout اصلی، درون تگ `<head>`، یک تگ `<script>` اضافه می‌کنیم.
3.  اتریبیوت `src` این تگ را برابر با آدرس CDN مربوط به Tailwind CSS قرار می‌دهیم.

**کد نمونه:**

```html:views/components/layout.blade.php
<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-100">
<head>
    <meta charset="UTF-8">
    <title>My App</title>
    {{-- اضافه کردن Tailwind CSS از طریق CDN --}}
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="h-full">
    {{-- ... بقیه محتوای layout --}}
</body>
</html>
```

**فلوی معنایی (Semantic Flow):**

1.  مرورگر هنگام خواندن فایل HTML، به تگ `<script>` می‌رسد.
2.  درخواست برای دریافت فایل جاوااسکریپت موجود در آدرس `src` به سرور CDN ارسال می‌شود.
3.  این فایل جاوااسکریپت، به صورت پویا تمام کلاس‌های کاربردی (Utility Classes) فریم‌ورک Tailwind را بر اساس کلاس‌هایی که شما در HTML خود استفاده کرده‌اید، تولید و به صفحه تزریق می‌کند.
4.  در نتیجه، صفحه‌ای که قبلاً بدون استایل بود، اکنون با استایل‌های مدرن Tailwind نمایش داده می‌شود.

**ارتباط بین فایل‌ها و کدها:**

```
مرورگر (Browser)
 │
 └── درخواست برای رندر صفحه
      │
      └── views/components/layout.blade.php
           │
           └── <script src="...">
                │
                └── درخواست به cdn.tailwindcss.com برای دریافت استایل‌ها
```

**نکات کلیدی مهم:**

*   **استفاده از CDN:** این روش برای مراحل توسعه، یادگیری و نمونه‌سازی (Prototyping) بسیار عالی و سریع است. اما برای پروژه‌های واقعی (Production)، توصیه می‌شود از ابزارهای ساخت مانند Vite یا Webpack استفاده کنید تا فقط CSS مورد نیاز پروژه شما در فایل نهایی گنجانده شود و حجم آن بهینه باشد.
*   **اهمیت `<head>`:** قرار دادن این اسکریپت در تگ `<head>` تضمین می‌کند که استایل‌ها قبل از رندر شدن بدنه (body) صفحه بارگذاری شوند و از پدیده "Flash of Unstyled Content" (FOUC) جلوگیری شود.

---

### **بخش ۲: داینامیک کردن محتوای صفحات با Blade**

اکنون که ظاهر کلی برنامه را داریم، باید محتوای هر صفحه را به صورت داینامیک درون این layout قرار دهیم. اینجا قدرت سیستم کامپوننت و اسلات Blade نمایان می‌شود.

#### **۲.۲. معرفی اسلات‌های نام‌گذاری شده (Named Slots)**

گاهی یک کامپوننت بیش از یک بخش متغیر دارد. برای مثال، layout ما هم یک "محتوای اصلی" و هم یک "عنوان" متغیر دارد. اینجا از اسلات‌های نام‌گذاری شده استفاده می‌کنیم.

**فلوی گرامری (Grammar Flow):**

1.  در فایل `layout.blade.php`، به جای یک متغیر PHP مثل `$heading`، از یک متغیر Blade با دو آکولاد `{{ $heading }}` استفاده می‌کنیم. این متغیر نماینده یک اسلات نام‌گذاری شده است.
2.  در فایل‌های view فرزند (مانند `home.view.php`)، از یک تگ سفارشی به شکل `<x-slot:name>` استفاده می‌کنیم.
3.  `name` را با نام اسلات مورد نظر (در اینجا `heading`) جایگزین می‌کنیم.
4.  محتوای دلخواه خود را بین تگ باز و بسته `<x-slot>` قرار می‌دهیم.

**کد نمونه:**

```php:views/components/layout.blade.php
{{-- ... --}}
<header class="bg-white shadow">
    <div class="mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8">
        {{-- این متغیر، محتوای اسلات 'heading' را نمایش می‌دهد --}}
        <h1 class="text-3xl font-bold tracking-tight text-gray-900">{{ $heading }}</h1>
    </div>
</header>
<main>
    <div class="mx-auto max-w-7xl py-6 sm:px-6 lg:px-8">
        {{-- این اسلات پیش‌فرض است --}}
        {{ $slot }}
    </div>
</main>
{{-- ... --}}
```

```php:views/home.view.php
<x-layout>
    {{-- تزریق محتوا به اسلات 'heading' --}}
    <x-slot:heading>
        Home Page
    </x-slot:heading>

    {{-- محتوایی که در ادامه می‌آید، به صورت خودکار به اسلات پیش‌فرض (slot$) می‌رود --}}
    <h1>Hello from the Home Page.</h1>

    {{--
        خروجی نهایی در HTML:
        <h1 class="text-3xl ...">Home Page</h1>
        ...
        <main>
            ...
            <h1>Hello from the Home Page.</h1>
        </main>
    --}}
</x-layout>
```

**فلوی معنایی (Semantic Flow):**

1.  وقتی `home.view.php` رندر می‌شود، موتور Blade ابتدا کامپوننت `<x-layout>` را پیدا می‌کند.
2.  سپس به دنبال تگ‌های `<x-slot:...>` درون آن می‌گردد.
3.  محتوای درون تگ `<x-slot:heading>` را برداشته و در متغیر `$heading` در فایل `layout.blade.php` قرار می‌دهد.
4.  هر محتوای دیگری که مستقیماً درون `<x-layout>` باشد (و در هیچ `<x-slot>` دیگری نباشد) را برداشته و در متغیر پیش‌فرض `$slot` قرار می‌دهد.
5.  در نهایت، `layout.blade.php` با متغیرهای پر شده (`$heading` و `$slot`) به عنوان HTML نهایی رندر می‌شود.

**ارتباط بین فایل‌ها و کدها:**

```
views/home.view.php
 │
 ├── defines <x-slot:heading>
 │
 └── defines default slot content
      │
      └── injects into a variable in
           │
           └── views/components/layout.blade.php
                ├── renders `{{ $heading }}`
                └── renders `{{ $slot }}`
```

**نکات کلیدی مهم:**

*   **خوانایی و تفکیک:** اسلات‌های نام‌گذاری شده به ما اجازه می‌دهند که بخش‌های مختلف یک کامپوننت را به صورت کاملاً خوانا و مجزا از هم مقداردهی کنیم. این کار به شدت به تمیزی کد در viewهای فرزند کمک می‌کند.
*   **انعطاف‌پذیری:** شما می‌توانید هر تعداد اسلات نام‌گذاری شده که نیاز دارید در کامپوننت خود تعریف کنید (`footer`, `sidebar`, `scripts`, ...)، که این کامپوننت‌ها را بسیار قدرتمند و انعطاف‌پذیر می‌کند.

---

### **بخش ۳: مدیریت هوشمند لینک‌های ناوبری (Navigation)**

یک چالش رایج در وب‌اپلیکیشن‌ها، نمایش بصری صفحه‌ای است که کاربر در حال حاضر در آن قرار دارد (مثلاً هایلایت کردن لینک آن در منو). در این بخش، این چالش را به روشی استاندارد حل می‌کنیم.

#### **۳.۲.۲. تشخیص مسیر فعلی با تابع کمکی `request()->is()`**

**فلوی گرامری (Grammar Flow):**

1.  درون تگ `<a>`، برای اتریبیوت `class`، از یک عبارت شرطی PHP استفاده می‌کنیم.
2.  شرط ما، فراخوانی تابع کمکی `request()` و سپس متد `is('path')` روی آن است. این متد چک می‌کند که آیا مسیر URI فعلی با الگوی داده شده (مثلاً `/` برای صفحه اصلی یا `about` برای صفحه درباره ما) مطابقت دارد یا خیر.
3.  اگر شرط `true` بود، کلاس‌های CSS مربوط به لینک فعال را برمی‌گردانیم.
4.  اگر شرط `false` بود، کلاس‌های CSS مربوط به لینک غیرفعال را برمی‌گردانیم.
5.  همین منطق را برای اتریبیوت `aria-current` نیز پیاده‌سازی می‌کنیم تا برنامه ما برای صفحه‌خوان‌ها (Screen Readers) نیز قابل دسترس باشد.

**کد نمونه:**

```php:views/partials/nav.php (مثال ساده شده از منطق)
<div class="space-x-4">
    <a href="/"
       class="{{ request()->is('/') ? 'bg-gray-900 text-white' : 'text-gray-300 hover:bg-gray-700' }} rounded-md px-3 py-2 text-sm font-medium"
       aria-current="{{ request()->is('/') ? 'page' : 'false' }}">Home</a>

    <a href="/about"
       class="{{ request()->is('about') ? 'bg-gray-900 text-white' : 'text-gray-300 hover:bg-gray-700' }} rounded-md px-3 py-2 text-sm font-medium"
       aria-current="{{ request()->is('about') ? 'page' : 'false' }}">About</a>
</div>
```

**فلوی معنایی (Semantic Flow):**

1.  کاربر روی لینک "About" کلیک می‌کند و به آدرس `your-site.com/about` می‌رود.
2.  لاراول درخواست را پردازش می‌کند. در این لحظه، URI درخواست برابر با `about` است.
3.  هنگام رندر کردن منوی ناوبری:
    *   برای لینک "Home"، شرط `request()->is('/')` مقدار `false` برمی‌گرداند و استایل غیرفعال اعمال می‌شود.
    *   برای لینک "About"، شرط `request()->is('about')` مقدار `true` برمی‌گرداند و استایل فعال (`bg-gray-900 text-white`) اعمال می‌شود.
4.  در نتیجه، کاربر به صورت بصری متوجه می‌شود که در صفحه "About" قرار دارد.

**ارتباط بین فایل‌ها و کدها:**

```
Router (routes/web.php)
 │
 └── matches incoming URL to a controller/view
      │
      └── View (e.g., about.view.php)
           │
           └── includes navigation partial
                │
                └── nav.php
                     │
                     └── PHP code: request()->is(...)
                          │
                          └── inspects the current request URI
```

**نکات کلیدی مهم:**

*   **تابع `request()`:** یک تابع کمکی (Helper Function) سراسری و قدرتمند در لاراول است که دسترسی آسان به اطلاعات درخواست HTTP فعلی (شامل URI, Method, Headers, Inputs) را فراهم می‌کند.
*   **الگوهای `is()`:** متد `is()` بسیار انعطاف‌پذیر است. شما می‌توانید از wildcard `*` استفاده کنید. برای مثال `request()->is('notes/*')` برای تمام صفحات مربوط به یادداشت‌ها (مانند `notes/1` یا `notes/create`) مقدار `true` برمی‌گرداند.
*   **شلوغی کد (Code Clutter):** این روش کاملاً کار می‌کند، اما تکرار این منطق طولانی برای هر لینک، کد HTML ما را کثیف و نگهداری آن را دشوار می‌کند. این دقیقاً همان نقطه‌ای است که یک مهندس نرم‌افزار به فکر بازسازی (Refactoring) می‌افتد.

---

#### **۳.۳. بازسازی کد به یک کامپوننت `NavLink` (رویکرد حرفه‌ای)**

برای حل مشکل شلوغی کد و تکرار منطق، ما تمام این قابلیت‌ها را در یک کامپوننت Blade قابل استفاده مجدد به نام `NavLink` کپسوله می‌کنیم.

**فلوی گرامری (Grammar Flow):**

1.  یک فایل جدید در `views/components/nav-link.blade.php` ایجاد می‌کنیم.
2.  در بالای این فایل، با استفاده از دایرکتیو `@props`، مشخص می‌کنیم که این کامپوننت چه پراپرتی‌های سفارشی (Props) را می‌پذیرد. ما یک `href` و یک پراپرتی boolean به نام `active` تعریف می‌کنیم.
3.  کد HTML تگ `<a>` را به این فایل منتقل می‌کنیم.
4.  به جای مقادیر ثابت، از متغیرهای prop استفاده می‌کنیم (`{{ $href }}`).
5.  برای کلاس‌ها، از پراپرتی `$active` در یک شرط سه‌تایی استفاده می‌کنیم.
6.  در فایل `nav.php`، تگ‌های `<a>` قبلی را با تگ کامپوننت جدید `<x-nav-link>` جایگزین می‌کنیم.
7.  مقادیر `href` و `active` را به صورت اتریبیوت به این کامپوننت پاس می‌دهیم.

**کد نمونه:**

```php:views/components/nav-link.blade.php
@props(['href', 'active' => false]) {{-- تعریف props --}}

<a href="{{ $href }}"
   class="{{ $active ? 'bg-gray-900 text-white' : 'text-gray-300 hover:bg-gray-700' }} rounded-md px-3 py-2 text-sm font-medium"
   aria-current="{{ $active ? 'page' : 'false' }}"
>
    {{ $slot }} {{-- محتوای بین تگ کامپوننت در اینجا قرار می‌گیرد --}}
</a>
```

```php:views/partials/nav.php
<div class="space-x-4">
    {{-- استفاده از کامپوننت جدید با پاس دادن props --}}
    <x-nav-link href="/" :active="request()->is('/')">Home</x-nav-link>
    <x-nav-link href="/about" :active="request()->is('about')">About</x-nav-link>
    <x-nav-link href="/contact" :active="request()->is('contact')">Contact</x-nav-link>

    {{--
        خروجی برای لینک Home در صفحه اصلی:
        <a href="/" class="bg-gray-900 text-white ..." aria-current="page">Home</a>

        خروجی برای لینک Home در صفحه About:
        <a href="/" class="text-gray-300 hover:bg-gray-700 ..." aria-current="false">Home</a>
    --}}
</div>
```

**فلوی معنایی (Semantic Flow):**

1.  در فایل `nav.php`، موتور Blade تگ `<x-nav-link>` را می‌بیند.
2.  مقدار `href` را به عنوان یک رشته و نتیجه‌ی `request()->is('/')` (که `true` یا `false` است) را به عنوان پراپرتی `active` به کامپوننت `nav-link.blade.php` پاس می‌دهد.
3.  متن قرار گرفته بین تگ‌های `<x-nav-link>` (یعنی "Home") به اسلات پیش‌فرض (`$slot`) منتقل می‌شود.
4.  کامپوننت `nav-link` با استفاده از این مقادیر (`href`, `active`, `slot`)، تگ `<a>` نهایی را با کلاس‌ها و اتریبیوت‌های صحیح تولید می‌کند.
5.  نتیجه نهایی، کدی بسیار تمیزتر، خواناتر و قابل نگهداری در `nav.php` است، در حالی که تمام منطق پیچیده در کامپوننت `NavLink` پنهان شده است.

**ارتباط بین فایل‌ها و کدها:**

```
views/partials/nav.php
 │
 └── uses <x-nav-link> component
      │
      ├── passes `href` prop
      ├── passes `active` prop (using request()->is())
      └── passes `slot` content (the link text)
           │
           └── to be processed by
                │
                └── views/components/nav-link.blade.php
                     │
                     └── generates the final <a> tag with conditional logic
```

**نکات کلیدی مهم:**

*   **Props vs Attributes:** پراپ‌ها (`@props`) داده‌های سفارشی هستند که شما برای کنترل منطق کامپوننت خود تعریف می‌کنید. اتریبیوت‌ها (`$attributes`) مجموعه‌ای از اتریبیوت‌های استاندارد HTML هستند (مانند `id`, `class`, `data-*`) که می‌توانید مستقیماً به تگ اصلی در کامپوننت خود منتقل کنید. این تفکیک برای ساخت کامپوننت‌های تمیز ضروری است.
*   **سینتکس `:` برای Props:** وقتی می‌خواهید یک متغیر PHP یا نتیجه یک تابع (و نه یک رشته ثابت) را به یک prop پاس دهید، باید قبل از نام آن از `:` استفاده کنید (مثلاً `:active="..."`). این به Blade می‌گوید که محتوای داخل "" را به عنوان کد PHP اجرا کند.
*   **اصل تک مسئولیتی (Single Responsibility Principle):** این بازسازی یک مثال کلاسیک از این اصل مهم مهندسی نرم‌افزار است. کامپوننت `NavLink` اکنون فقط یک مسئولیت دارد: رندر کردن یک لینک ناوبری با استایل‌دهی فعال/غیرفعال. فایل `nav.php` هم فقط یک مسئولیت دارد: لیست کردن لینک‌های ناوبری. این تفکیک، کد را برای آینده بسیار مقیاس‌پذیرتر و قابل فهم‌تر می‌کند.